---
title: "LeetCode 383. Ransom Note"
emoji: "ğŸ–‹"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["leetcode", "go"]
published: true
---
## ã¯ã˜ã‚ã«
LeetCode ã€Œ383. Ransom Noteã€ã®å•é¡Œã‚’Goã§è§£ãã¾ã—ãŸã€‚

## å•é¡Œ
https://leetcode.com/problems/ransom-note/description/

### å•é¡Œæ–‡
Given two strings `ransomNote` and `magazine`, return `true` if `ransomNote` can be constructed by using the letters from `magazine` and `false` otherwise.
Each letter in `magazine` can only be used once in `ransomNote`.

**å’Œè¨³**
2ã¤ã®æ–‡å­—åˆ— `ransomNote` ã¨ `magazine` ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€`magazine` ã®æ–‡å­—ã‚’ä½¿ã£ã¦ `ransomNote` ã‚’ä½œæˆã§ãã‚‹å ´åˆã¯ `true` ã‚’ã€ãã†ã§ãªã„å ´åˆã¯ `false` ã‚’è¿”ã—ã¾ã™ã€‚
 `magazine` ã®å„æ–‡å­—ã¯ã€`ransomNote` ã§ã¯ä¸€åº¦ã—ã‹ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚

### ä¾‹
1.
```
Input: ransomNote = "a", magazine = "b"
Output: false
```

2.
```
Input: ransomNote = "aa", magazine = "ab"
Output: false
```

3.
```
Input: ransomNote = "aa", magazine = "aab"
Output: true
```

### åˆ¶ç´„
- 1 <= ransomNote.length, magazine.length <= 105
- ransomNote and magazine consist of lowercase English letters.

## è§£ç­”1
`ransomNote` ã®å„æ–‡å­—ãŒ `magazine` ã«ã€Œååˆ†ãªæ•°ã€å«ã¾ã‚Œã¦ã„ã‚Œã° true ã‚’è¿”ã™ã€ã¨ã„ã†å•é¡Œã§ã™ã€‚
ã¾ãšä»¥ä¸‹ã®ã‚ˆã†ãªå®Ÿè£…ã‚’è€ƒãˆã¾ã—ãŸã€‚

**byte**ã‚’ã‚­ãƒ¼ã€**intã‚’**ãƒãƒªãƒ¥ãƒ¼ã¨ã—ã¦æŒã¤ãƒãƒƒãƒ—ã‚’ä½œã‚Šã¾ã™ã€‚
ãã“ã«`magazine`ã®å„æ–‡å­—ã®å‡ºç¾å›æ•°ã‚’è¨˜éŒ²ã—ã€`ransomNote`ã‚’æœæŸ»ã—ãªãŒã‚‰æ–‡å­—ãŒå‡ºç¾ã—ãŸã‚‰ãƒãƒªãƒ¥ãƒ¼ã‚’å¼•ãã¾ã™ã€‚
ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã¯å­˜åœ¨ã—ãªã„ã€ã‚ã‚‹ã„ã¯ãƒãƒªãƒ¥ãƒ¼ãŒ0ä»¥ä¸‹ã«ãªã£ãŸã‚‰falseã¨åˆ¤å®šã—ã¾ã™ã€‚

### ã‚³ãƒ¼ãƒ‰
```go
func canConstruct(ransomNote string, magazine string) bool {
	rnLen := len(ransomNote)
	mzLen := len(magazine)

	charMap := make(map[byte]int)

	for i := range mzLen {
		charMap[magazine[i]]++
	}

	for i := range rnLen {
		val, ok := charMap[ransomNote[i]]
		if ok == false || val <= 0 {
			return false
		}
		charMap[ransomNote[i]]--
	}

	return true
}
```

#### è£œè¶³
`for i := range mzLen`ã¨ã„ã†æ›¸ãæ–¹ã¯ã€go1.22 ã‹ã‚‰å¯èƒ½ã§ã™ã€‚
ãã‚Œä»¥å‰ã®å ´åˆã¯ã€`for i := 0; i < mzLen; i++`ã¨ã„ã†å½¢ã§è¨˜è¿°ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/modernize#rangeint

### è¨ˆç®—é‡
- æ™‚é–“çš„è¨ˆç®—é‡ï¼šO(m + n)
- ç©ºé–“çš„è¨ˆç®—é‡ï¼šO(1)

## è§£ç­”2
è§£ç­”1ã¯ `map[byte]int`ã‚’ä½œã‚Šã¾ã—ãŸãŒã€å›ºå®šé•·é…åˆ— `[26]int` ã‚’ä½¿ã†ã“ã¨ã§çœãƒ¡ãƒ¢ãƒªã§åŠ¹ç‡ã®è‰¯ã„å®Ÿè£…ãŒå¯èƒ½ã§ã™ã€‚

### ã‚³ãƒ¼ãƒ‰
```go
func canConstruct(ransomNote string, magazine string) bool {
	charCounts := make([]int, 26) // 'a'ã€œ'z'

	for i := 0; i < len(magazine); i++ {
		charCounts[magazine[i]-'a']++
	}

	for i := 0; i < len(ransomNote); i++ {
		charCounts[ransomNote[i]-'a']--
		if charCounts[ransomNote[i]-'a'] < 0 {
			return false
		}
	}

	return true
}
```

**charCounts[0]** ã¯ `a` ã®å‡ºç¾å›æ•°ã€**charCounts[1]** ã¯ `b` ã®å‡ºç¾å›æ•°...ã¨ã„ã£ãŸå½¢ã¨ãªã‚Šã€
ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ = å¯¾å¿œã™ã‚‹æ–‡å­—ã¨ã—ã¦æ‰±ã£ã¦ã„ã¾ã™ã€‚

`magazine[i] - 'a'` ã®éƒ¨åˆ†ã§æ–‡å­—ã‚’0~25ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯æ–‡å­— 'a' ã®ASCIIå€¤ï¼ˆ97ï¼‰ã‚’å¼•ã„ã¦ã„ã‚‹ã®ã§ã€ãŸã¨ãˆã° 'c'ï¼ˆ99ï¼‰ã¯ 99 - 97 = 2 ã¨ãªã‚Šã¾ã™ã€‚

2ã¤ç›®ã®foræ–‡ã§ã¯ã€è©²å½“ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å€¤ã‹ã‚‰1ã‚’å¼•ãã€ãƒã‚¤ãƒŠã‚¹ã«ãªã£ãŸæ™‚ç‚¹ã§falseã¨åˆ¤å®šã§ãã¾ã™ã€‚

### è¨ˆç®—é‡
- æ™‚é–“çš„è¨ˆç®—é‡ï¼šO(m + n)
- ç©ºé–“çš„è¨ˆç®—é‡ï¼šO(1)