---
title: "LeetCode 101. Symmetric Tree"
emoji: "ğŸ–‹"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["leetcode", "go"]
published: true
---
## ã¯ã˜ã‚ã«
LeetCode ã€Œ101. Symmetric Treeã€ã®å•é¡Œã‚’Goã§è§£ãã¾ã—ãŸã€‚

## å•é¡Œ
https://leetcode.com/problems/symmetric-tree/description/

### å•é¡Œæ–‡
Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

**å’Œè¨³**
äºŒåˆ†æœ¨ã®`root`ãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€ãã‚ŒãŒãã‚Œè‡ªèº«ã®é¡ï¼ˆã™ãªã‚ã¡ã€ãã®ä¸­å¿ƒã‚’ä¸­å¿ƒã«å¯¾ç§°ï¼‰ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€‚

### ä¾‹
1.
```
         1          
      /     \        
     2       2    
   /  \     /  \    
  3    4   4    3    
```

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

2.
```
         1          
      /     \        
     2       2    
      \        \    
       3        3    
```

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```


### åˆ¶ç´„
- The number of nodes in the tree is in the range [1, 1000].
- -100 <= Node.val <= 100

## è§£ç­”1:DFSï¼ˆæ·±ã•å„ªå…ˆæ¤œç´¢ãƒ»å†å¸°ï¼‰
äºŒåˆ†æœ¨ãŒå·¦å³å¯¾ç§°ã‹ã‚’åˆ¤å®šã™ã‚‹å•é¡Œã§ã™ã€‚
å·¦å³ã®ï¼’ã¤ã®ãƒãƒ¼ãƒ‰ã®å¯¾ç§°æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚

isMirroré–¢æ•°ã§ã¯ã€2ã¤ã®ãƒãƒ¼ãƒ‰pã¨qã«å¯¾ã—ã¦ã€ä»¥ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
- ä¸¡è€…ãŒnil: `true`
- ç‰‡æ–¹ã ã‘nil: `false`
- å€¤ãŒé•ã†: `false`
- å†å¸°çš„ã« p.Left ã¨ q.Right, p.Right ã¨ q.Left ãŒé¡ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯

å…¨ä½“ã®ãƒ«ãƒ¼ãƒˆã«å¯¾ã—ã¦ã€ä¸Šè¨˜ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚

### ã‚³ãƒ¼ãƒ‰
```go
func isSymmetric(root *TreeNode) bool {
    return isMirror(root.Left, root.Right)
}

func isMirror(p, q *TreeNode) bool {
    if p == nil && q == nil {
        return true
    }

    if p == nil || q == nil {
        return false
    }

    if p.Val != q.Val {
        return false
    }

    return isMirror(p.Left, q.Right) && isMirror(p.Right, q.Left)
}
```

### è¨ˆç®—é‡
- æ™‚é–“çš„è¨ˆç®—é‡ï¼šO(n)
  - n ã¯ãƒãƒ¼ãƒ‰æ•°ï¼ˆå„ãƒãƒ¼ãƒ‰ã‚’1å›ãšã¤è¨ªã‚Œã‚‹ï¼‰
- ç©ºé–“çš„è¨ˆç®—é‡ï¼šO(h)
  - h ã¯æœ¨ã®é«˜ã•ï¼ˆå†å¸°å‘¼ã³å‡ºã—ã®ã‚¹ã‚¿ãƒƒã‚¯ãŒæœ¨ã®é«˜ã•åˆ†ä½¿ã‚ã‚Œã‚‹ï¼‰


## è§£ç­”2ï¼šBFSï¼ˆå¹…å„ªå…ˆæ¢ç´¢ã€Queueä½¿ç”¨ï¼‰
è§£ç­”1ã§ã¯å†å¸°çš„ã«æ·±ã•å„ªå…ˆã§æœ¨ã‚’æ¢ç´¢ã—ã¾ã—ãŸãŒã€ã‚­ãƒ¥ãƒ¼ã‚’ä½¿ã£ãŸå¹…å„ªå…ˆæ¢ç´¢ã§ã‚‚åŒæ§˜ã«å¯¾ç§°æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚
ãƒã‚¤ãƒ³ãƒˆã¯ã€**å·¦å³å¯¾ç§°ã‹ã©ã†ã‹** ã‚’ãƒãƒ¼ãƒ‰ã®ãƒšã‚¢ã‚’ä½¿ã£ã¦éƒ½åº¦ãƒã‚§ãƒƒã‚¯ã™ã‚‹ç‚¹ã§ã™ã€‚

1å›ç›®ã®ãƒ«ãƒ¼ãƒ—ã§ queue = `[2, 2]` â†’ å€¤ã¯ç­‰ã—ã„ã®ã§æ¬¡ã¸
2å›ç›®: queue = `[3, 3, 4, 4]` â†’ ä¸¡ãƒšã‚¢ã¨ã‚‚å€¤ãŒç­‰ã—ã„ â†’ æ¬¡ã¸
...
ã¨ã„ã£ãŸã‚ˆã†ã«ã€å„ãƒšã‚¢ã‚’å–ã‚Šå‡ºã—ã¦æ¯”è¼ƒã—ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚

### ã‚³ãƒ¼ãƒ‰
```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }

    queue := []*TreeNode{root.Left, root.Right}

    for len(queue) > 0 {
        p := queue[0]
        q := queue[1]
        queue = queue[2:]

        if p == nil && q == nil {
            continue
        }

        if p == nil || q == nil {
            return false
        }

        if p.Val != q.Val {
            return false
        }

        // é¡ã®é †ç•ªã§è¿½åŠ 
        queue = append(queue, p.Left, q.Right)
        queue = append(queue, p.Right, q.Left)
    }

    return true
}
```

### è¨ˆç®—é‡
- æ™‚é–“çš„è¨ˆç®—é‡ï¼šO(n)
  - n ã¯ãƒãƒ¼ãƒ‰æ•°ï¼ˆå„ãƒãƒ¼ãƒ‰ã‚’1å›ãšã¤è¨ªã‚Œã‚‹ï¼‰
- ç©ºé–“çš„è¨ˆç®—é‡ï¼šO(w)
  - w ã¯æœ¨ã®æœ€å¤§å¹…ï¼ˆQueue ã«æœ€å¤§ã§ä¸€åº¦ã«ä¿æŒã™ã‚‹ãƒãƒ¼ãƒ‰æ•°ï¼‰


## å‚è€ƒ
äºŒåˆ†æœ¨ã®å•é¡Œã¯ã€ä»¥ä¸‹ã®è¨˜äº‹ã§ã‚‚ç´¹ä»‹ã—ã¦ã„ã¾ã™ã®ã§ã€å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚
- [LeetCode 100. Same Tree](https://zenn.dev/shimpo/articles/leet-code-100-20250608)
- [LeetCode 104. Maximum Depth of Binary Tree](https://zenn.dev/shimpo/articles/leet-code-104-20250607)
- [LeetCode 226. Invert Binary Tree](https://zenn.dev/shimpo/articles/leet-code-226-20250610)